generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  CONSUMER
  COOP
  PRODUCER
}

enum DisputeReason {
  NO_DELIVERY
  SPOILED
  OTHER
}

enum Notification {
  SMS_ALL_ORDERS
  EMAIL_ALL_ORDERS
  SMS_NEW_ORDERS
  EMAIL_NEW_ORDERS
  SMS_ORDER_UPDATES
  EMAIL_ORDER_UPDATES
  SMS_ORDER_CANCELED
  EMAIL_ORDER_CANCELED
  SMS_ORDER_COMPLETED
  EMAIL_ORDER_COMPLETED
  SMS_FOLLOWED_USER_LISTING
  EMAIL_FOLLOWED_USER_LISTING
  SMS_NEW_PRODUCER_LISTINGS
  EMAIL_NEW_PRODUCER_LISTINGS
}

type notifList {
  list String[]
}

type Times {
  open  Int
  close Int
}

type LocationObj {
  type        String
  coordinates Float[]
  address     String[]
  hours       Hours?
  role        UserRole @default(CONSUMER)
  isDefault   Boolean? @default(false)
}

type Hours {
  deliveryHours      MonthHours[]
  pickupHours        MonthHours[]
  deliveryExceptions StoreException[]
  pickupExceptions   StoreException[]
}

type MonthHours {
  month Int
  days  DayHours[]
}

type OpenCloseTemplates {
  title     String
  timeSlots TimeSlot[]
}

type DayHours {
  day       Int
  timeSlots TimeSlot[]
}

type TimeSlot {
  open  Int
  close Int
}

type StoreException {
  date      DateTime
  timeSlots TimeSlot[]
}

model Location {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  userId      String    @db.ObjectId
  user        User      @relation(fields: [userId], references: [id])
  listings    Listing[]
  type        String
  coordinates Float[]
  address     String[]
  hours       Hours?
  role        UserRole  @default(CONSUMER)
  isDefault   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model User {
  id            String     @id @default(auto()) @map("_id") @db.ObjectId
  name          String
  email         String     @unique
  firstName     String?
  emailVerified DateTime?
  phoneNumber   String?
  locations     Location[]
  image         String?

  role                  UserRole               @default(PRODUCER)
  password              String?
  stripeAccountId       String?
  totalPaidOut          Int?
  notifications         Notification[]
  SODT                  Int? // set out and delivery time for co-ops/producers respectively expressed as an integer
  bio                   String? // bio for co-ops and producers (should consumer have bios?)
  banner                String? // banner for co-op and producer stores
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  url                   String?
  conversationIds       String[]               @db.ObjectId
  conversations         Conversation[]         @relation(fields: [conversationIds], references: [id])
  seenMessageIds        String[]               @db.ObjectId
  seenMessages          Message[]              @relation("Seen", fields: [seenMessageIds], references: [id])
  favoriteIds           String[]               @db.ObjectId
  accounts              Account[]
  listings              Listing[]
  cart                  Cart[]
  following             Following?
  buyerOrders           Order[]                @relation("buyer")
  sellerOrders          Order[]                @relation("seller")
  sentMessages          Message[]              @relation("SentMessages")
  twoFactorConfirmation TwoFactorConfirmation?
  subscriptions         String?
  hasPickedRole         Boolean?
  openCloseTemplates    OpenCloseTemplates[]
}

model Following {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  userId  String   @db.ObjectId
  follows String[]
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}

model Reviews {
  id         String  @id @default(auto()) @map("_id") @db.ObjectId
  reviewerId String  @db.ObjectId
  reviewedId String  @db.ObjectId
  buyer      Boolean
  review     String
  rating     Int
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(cuid()) @map("_id")
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid()) @map("_id")
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorToken {
  id      String   @id @default(cuid()) @map("_id")
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id String @id @default(cuid()) @map("_id")

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}

model Listing {
  id              String     @id @default(auto()) @map("_id") @db.ObjectId
  SODT            Int? //set out and delivery time for co-ops/producers respectively expressed as an interger
  title           String
  category        String // "homemade", "unprocessed-produce", "dairy-meats", "durables" 
  subCategory     String
  stock           Int
  quantityType    String
  price           Float
  description     String
  projectedStock  Int?
  harvestFeatures Boolean?
  harvestDates    String[]
  keyWords        String[]
  minOrder        Int
  imageSrc        String[]
  review          Boolean?
  harvestType     String?
  reports         Int?
  shelfLife       Int
  locationId      String     @db.ObjectId
  location        Location   @relation(fields: [locationId], references: [id])
  rating          Int[]
  userId          String     @db.ObjectId
  createdAt       DateTime   @default(now())
  emailList       notifList?
  smsList         notifList?

  user User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  cart Cart[]
}

model Cart {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  userId    String    @db.ObjectId
  listingId String    @db.ObjectId
  quantity  Int       @default(1)
  pickup    DateTime?
  price     Float

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@unique([userId, listingId])
}

model TransactionHistory {
  id         String @id @default(auto()) @map("_id") @db.ObjectId
  orderId    String @db.ObjectId
  totalPrice Float
}

model Order {
  id              String      @id @default(auto()) @map("_id") @db.ObjectId
  userId          String      @db.ObjectId
  listingIds      String[]
  sellerId        String      @db.ObjectId
  pickupDate      DateTime
  paymentIntentId String?
  quantity        String
  totalPrice      Float
  status          Int         @default(0)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  completedAt     DateTime?
  fee             Float
  location        LocationObj
  conversationId  String?     @db.ObjectId
  payments        Payment[]

  dispute Dispute?
  buyer   User?    @relation(name: "buyer", fields: [userId], references: [id])
  seller  User?    @relation(name: "seller", fields: [sellerId], references: [id])
}

model Payment {
  id                    String   @id @default(auto()) @map("_id") @db.ObjectId
  orderId               String   @db.ObjectId
  stripePaymentIntentId String
  amount                Float
  status                String
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model StripeIntents {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  paymentIds String[] @db.ObjectId
}

model Conversation {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt     DateTime @default(now())
  lastMessageAt DateTime @default(now())
  name          String?
  isGroup       Boolean?

  messagesIds String[]  @db.ObjectId
  messages    Message[]

  userIds String[] @db.ObjectId
  users   User[]   @relation(fields: [userIds], references: [id])
}

model Message {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  body         String?
  image        String?
  createdAt    DateTime @default(now())
  messageOrder String?
  listingId    String?  @db.ObjectId
  seenIds      String[] @db.ObjectId
  seen         User[]   @relation("Seen", fields: [seenIds], references: [id])

  conversationId String       @db.ObjectId
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId String @db.ObjectId
  sender   User   @relation("SentMessages", fields: [senderId], references: [id])
}

model Dispute {
  id          String        @id @default(auto()) @map("_id") @db.ObjectId
  orderId     String        @unique @db.ObjectId
  userId      String        @db.ObjectId
  email       String
  phone       String
  status      Int           @default(0)
  images      String[]
  reason      DisputeReason
  explanation String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  order       Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Suggestion {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  name        String   @unique
  category    String
  subCategory String
  createAt    DateTime @default(now())
}
