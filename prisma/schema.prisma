generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  CONSUMER
  COOP
  PRODUCER
}

enum DisputeReason {
  NO_DELIVERY
  SPOILED
  OTHER
}

enum Notification {
  SMS_ALL_ORDERS
  EMAIL_ALL_ORDERS
  SMS_NEW_ORDERS
  EMAIL_NEW_ORDERS
  SMS_ORDER_UPDATES
  EMAIL_ORDER_UPDATES
  SMS_ORDER_CANCELED
  EMAIL_ORDER_CANCELED
  SMS_ORDER_COMPLETED
  EMAIL_ORDER_COMPLETED
  SMS_FOLLOWED_USER_LISTING
  EMAIL_FOLLOWED_USER_LISTING
  SMS_NEW_PRODUCER_LISTINGS
  EMAIL_NEW_PRODUCER_LISTINGS
}

type notifList {
  list String[]
}

type Times {
  open  Int
  close Int
}

type LocationObj {
  type        String
  coordinates Float[]
  address     String[]
  hours       Hours?
  role        UserRole?
}

type Hours {
  monthHours MonthHours[]
  exceptions StoreException[]
}

type MonthHours {
  month Int // 0-11 for Jan to Dec
  days  DayHours[]
}

type DayHours {
  day       Int // 0-6 for Sun to Sat
  timeSlots TimeSlot[]
}

type TimeSlot {
  open  Int // Time in minutes from midnight
  close Int // Time in minutes from midnight
}

type StoreException {
  date      DateTime
  timeSlots TimeSlot[] // Optional for specific open/close hours on that date
}

type Location {
  0 LocationObj? @map("0")
  1 LocationObj? @map("1")
  2 LocationObj? @map("2")
}

model User {
  id            String    @id @default(auto()) @map("_id") @db.ObjectId
  name          String
  email         String    @unique
  firstName     String?
  emailVerified DateTime?
  phoneNumber   String?
  location      Location?
  image         String?

  role                  UserRole               @default(CONSUMER)
  password              String?
  stripeAccountId       String?
  totalPaidOut          Int?
  notifications         Notification[]
  SODT                  Int? // set out and delivery time for co-ops/producers respectively expressed as an integer
  bio                   String? // bio for co-ops and producers (should consumer have bios?)
  banner                String? // banner for co-op and producer stores
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  url                   String?
  conversationIds       String[]               @db.ObjectId
  conversations         Conversation[]         @relation(fields: [conversationIds], references: [id])
  seenMessageIds        String[]               @db.ObjectId
  seenMessages          Message[]              @relation("Seen", fields: [seenMessageIds], references: [id])
  favoriteIds           String[]               @db.ObjectId
  accounts              Account[]
  listings              Listing[]
  cart                  Cart[]
  following             Following?
  buyerOrders           Order[]                @relation("buyer")
  sellerOrders          Order[]                @relation("seller")
  sentMessages          Message[]              @relation("SentMessages")
  twoFactorConfirmation TwoFactorConfirmation?
  subscriptions         String?
  hasPickedRole         Boolean?
}

model Following {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  userId  String   @db.ObjectId
  follows String[]
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}

model Reviews {
  id         String  @id @default(auto()) @map("_id") @db.ObjectId
  reviewerId String  @db.ObjectId
  reviewedId String  @db.ObjectId
  buyer      Boolean
  review     String
  rating     Int
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(cuid()) @map("_id")
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid()) @map("_id")
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorToken {
  id      String   @id @default(cuid()) @map("_id")
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id String @id @default(cuid()) @map("_id")

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}

model Listing {
  id              String     @id @default(auto()) @map("_id") @db.ObjectId
  SODT            Int? //set out and delivery time for co-ops/producers respectively expressed as an interger
  title           String
  category        String // "homemade", "unprocessed-produce", "dairy-meats", "durables" 
  subCategory     String
  stock           Int
  quantityType    String
  price           Float
  description     String
  projectedStock  Int?
  harvestFeatures Boolean?
  harvestDates    String[]
  keyWords        String[]
  minOrder        Int
  imageSrc        String[]
  review          Boolean?
  harvestType     String?
  reports         Int?
  shelfLife       Int
  location        Int        @default(0)
  rating          Int[]
  userId          String     @db.ObjectId
  createdAt       DateTime   @default(now())
  emailList       notifList?
  smsList         notifList?

  user User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  cart Cart[]
}

model Cart {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  userId    String    @db.ObjectId
  listingId String    @db.ObjectId
  quantity  Int       @default(1)
  pickup    DateTime?
  price     Float

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@unique([userId, listingId])
}

model TransactionHistory {
  id         String @id @default(auto()) @map("_id") @db.ObjectId
  orderId    String @db.ObjectId
  totalPrice Float
}

model Order {
  id              String      @id @default(auto()) @map("_id") @db.ObjectId
  userId          String      @db.ObjectId
  listingIds      String[]
  sellerId        String      @db.ObjectId
  pickupDate      DateTime
  paymentIntentId String?
  quantity        String
  totalPrice      Float
  status          Int         @default(0)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  completedAt     DateTime?
  fee             Float
  location        LocationObj
  conversationId  String?     @db.ObjectId
  payments        Payment[]

  dispute Dispute?
  buyer   User?    @relation(name: "buyer", fields: [userId], references: [id])
  seller  User?    @relation(name: "seller", fields: [sellerId], references: [id])
}

model Payment {
  id                    String   @id @default(auto()) @map("_id") @db.ObjectId
  orderId               String   @db.ObjectId
  stripePaymentIntentId String
  amount                Float
  status                String
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model StripeIntents {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  paymentIds String[] @db.ObjectId
}

model Conversation {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt     DateTime @default(now())
  lastMessageAt DateTime @default(now())
  name          String?
  isGroup       Boolean?

  messagesIds String[]  @db.ObjectId
  messages    Message[]

  userIds String[] @db.ObjectId
  users   User[]   @relation(fields: [userIds], references: [id])
}

model Message {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  body         String?
  image        String?
  createdAt    DateTime @default(now())
  messageOrder String?
  listingId    String?  @db.ObjectId
  seenIds      String[] @db.ObjectId
  seen         User[]   @relation("Seen", fields: [seenIds], references: [id])

  conversationId String       @db.ObjectId
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId String @db.ObjectId
  sender   User   @relation("SentMessages", fields: [senderId], references: [id])
}

model Dispute {
  id          String        @id @default(auto()) @map("_id") @db.ObjectId
  orderId     String        @unique @db.ObjectId
  userId      String        @db.ObjectId
  email       String
  phone       String
  status      Int           @default(0)
  images      String[]
  reason      DisputeReason
  explanation String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  order       Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Suggestion {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  name        String   @unique
  category    String
  subCategory String
  createAt    DateTime @default(now())
}
